#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author  : Mike
# @Contact : 597290963@qq.com
# @Time    : 2021/2/21 22:01
# @File    : MinMalwareSpread2.py

# !/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author  : Mike
# @Contact : 597290963@qq.com
# @Time    : 2021/2/21 21:13
# @File    : MinMalwareSpread.py
from typing import List

"""
在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。

一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，
那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。

假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。

我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。

请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimize-malware-spread
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""


class UnionFind(object):

    def __init__(self, n):
        # 初始化并查集
        self.father = [i for i in range(n)]
        self.size = [1] * n  # 初始化size，记录每棵树的节点数

    def find(self, x):
        if self.father[x] == x:
            return x

        self.father[x] = self.find(self.father[x])
        return self.father[x]

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

    def union(self, x, y):
        # 基于size平衡优化
        if self.is_connected(x, y):
            return

        root_x = self.find(x)
        root_y = self.find(y)

        if self.size[root_x] < self.size[root_y]:
            root_x, root_y = root_y, root_x

        self.father[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        self.size[root_y] = 0

    def get_size(self, x):
        return self.size[self.find(x)]


class Solution:

    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        """
        并查集
        :param graph:
        :param initial:
        :return:
        """
        n = len(graph)
        min_m = n
        initial.sort()
        remove_idx = initial[0]

        for virus in initial:
            net = UnionFind(n)
            cur_m = 0
            for i in range(n):
                if i == virus: continue
                for j in range(n):
                    if virus != j and graph[i][j]:
                        net.union(i, j)

            ust_set = set()
            for v in initial:
                root = net.find(v)
                if root not in ust_set:
                    ust_set.add(root)
                    cur_m += net.get_size(root)

            if cur_m < min_m:
                min_m = cur_m
                remove_idx = virus

        return remove_idx


if __name__ == '__main__':
    print(Solution().minMalwareSpread([[1, 1, 0], [1, 1, 1], [0, 1, 1]], [0, 1]))
