#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author  : Mike
# @Contact : 597290963@qq.com
# @Time    : 2021/2/21 21:13
# @File    : MinMalwareSpread.py
from typing import List

"""
在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。

一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，
那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。

假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。

我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。

请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimize-malware-spread
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""


class UnionFind(object):

    def __init__(self, n):
        from collections import defaultdict
        # 初始化并查集
        self.father = [i for i in range(n)]
        self.size = [1] * n  # 初始化size，记录每棵树的节点数
        self.init_virus_cnt = defaultdict(int)  # 记录每个根节点被多少恶意病毒感染

    def find(self, x):
        if self.father[x] == x:
            return x

        self.father[x] = self.find(self.father[x])
        return self.father[x]

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

    def union(self, x, y):
        # 基于size平衡优化
        if self.is_connected(x, y):
            return

        root_x = self.find(x)
        root_y = self.find(y)

        if self.size[root_x] > self.size[root_y]:
            self.father[root_y] = root_x
            self.size[root_x] += self.size[root_y]
        else:
            self.father[root_x] = root_y
            self.size[root_y] += self.size[root_x]

    def spread(self, x):
        # 当某个网络传入病毒后，统计这个网络的源病毒数
        self.init_virus_cnt[self.find(x)] += 1


class Solution:

    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        """
        并查集
        :param graph:
        :param initial:
        :return:
        """
        n = len(graph)
        # 初始化网络，将各个网络连通
        net = UnionFind(n)
        for i in range(n):
            for j in range(n):
                if i != j and graph[i][j] == 1:
                    net.union(i, j)

        # 将源病毒传入网络
        for virus in initial:
            net.spread(virus)

        initial.sort()
        res = -1
        min_size = 0
        for virus in initial:
            # 找到当前病毒网络的根节点
            root = net.find(virus)
            cur_size = net.size[root]
            if net.init_virus_cnt[root] == 1 and cur_size > min_size:
                min_size = cur_size
                # 存储结果
                res = virus

        if res != -1:
            return res
        else:
            return initial[0]


if __name__ == '__main__':
    print(Solution().minMalwareSpread([[1, 1, 0], [1, 1, 1], [0, 1, 1]], [0, 1]))
